{-
    The Lodha Genius Programme, Continued Learning Module 2025
    
    Computational Thinking: When to Think, When to Compute


    An LGP number is a positive perfect square number such that: 
    1. Increasing its first (leftmost) digit by 1 produces another perfect square, and
    2. Increasing each digit by 1 produces yet another perfect square (leading zeros are not allowed). 
    
    For instance, 576 is a perfect square, and so is 676. However, 687 isn't a perfect square. 
    
    Find the smallest LGP number.
-}








{-

factorial n = 1 if n = 1, and n * factorial (n - 1) if n > 1
 
-}







factorial :: Int -> Int
factorial n
  | n <= 1    = 1
  | otherwise = n * factorial (n - 1)





sumMultiples3or5' :: Int -> Int
sumMultiples3or5' n
  | n <= 0                               = 0
  | (n `mod` 3 == 0) || (n `mod` 5 == 0) = n + sumMultiples3or5' (n-1)
  | otherwise                            = sumMultiples3or5' (n-1)










multiples3or5 :: [Int]
multiples3or5 = [x | x <- [0..1000], (x `mod` 3 == 0) || (x `mod` 5 == 0)]

sumList :: [Int] -> Int
sumList []      = 0
sumList (h : t) = h + sumList t






{-
Problem 2: Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

-}










fib :: Integer -> Integer
fib n
  | n < 0     = 0
  | n == 0    = 1
  | n == 1    = 1
  | otherwise = fib (n - 1) + fib (n - 2)

{-
[1..33] = [1, 2, 3, ... , 33]
-}

myFibList = [fib (n) | n <- [1..32]]

-- filter out the even numbers 

sumListInteger :: [Integer] -> Integer
sumListInteger []      = 0
sumListInteger (h : t) = h + sumListInteger t

problem3 :: [Integer] -> Integer
problem3 l = sumListInteger [x | x <- l, (x `mod` 2 == 0)]


{-
Given a threshold k, find the largest n for which fib(n) <= k.
-}

largestFibUnder :: Integer -> Integer
largestFibUnder 0 = 0
largestFibUnder k = largestFibUnder (k - 1) 








naturals :: [Integer]
naturals = [1..]





myMap :: (Integer -> Integer) -> [Integer] -> [Integer]
myMap f []      = []
myMap f (h : t) = (f h) : (myMap f t)

{-
list = myMap (^2) [1, 21, 13, 5, 6]
     = 1^2 : myMap (^2) [21, 13, 5, 6]
     = 1^2 : 21^2 : myMap (^2) [13, 5, 6]
     = 1^2 : 21^2 : 13^2 : myMap (^2) [5, 6]
     = 1^2 : 21^2 : 13^2 : 5^2 : 6^2 : []
     = [1, 441, 169, 25, 36]
-}




squares :: Integer -> [Integer]
squares n = myMap (^2) [1..n]


fibListInf :: [Integer]
fibListInf = myMap (fib) naturals




sumProblem2 :: [Integer] -> Integer
sumProblem2 [] = 0
sumProblem2 (h:t)
  | h > 4000000     = 0                     -- stop if x exceeds 4 million
  | h `mod` 2 == 0  = h + sumProblem2 t     -- add if even
  | otherwise       = sumProblem2 t         -- skip if odd




















fibHelper :: Integer -> Integer -> [Integer]
fibHelper a b = a : fibHelper b (a + b)


{-
1 : 2 : (1 + 2) : (2 + (1 + 2)) : ... 
a : b : (a + b) : (b + (a + b)) : ...
-}

fibList :: [Integer]
fibList = fibHelper 1 2





{- 
Problem 3: The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143?
-}


isPrime :: Integer -> Bool
isPrime n
  | n < 2     = False
  | otherwise = ([ x | x <- [2..(n - 1)], n `mod` x == 0 ] == [])



factors :: Integer -> [Integer] 
factors n = [x | x <- [1..n], n `mod` x == 0]


filterPrimes :: [Integer] -> [Integer]
filterPrimes [] = []
filterPrimes (h : t)
  | isPrime h = h : filterPrimes t
  | otherwise = filterPrimes t

primeFactors :: Integer -> [Integer]
primeFactors n = filterPrimes (factors n)





listMax :: [Integer] -> Integer
listMax [x]     = x
listMax (h : t) = max h (listMax t)


largestPrimeFactor :: Integer -> Integer
largestPrimeFactor n = listMax (primeFactors n)